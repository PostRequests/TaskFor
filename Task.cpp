#include "Task.h"
void Task::run() {
	Menu m;
	Position e;
	m.setColorText(RedBG, GreenFG)
		.setColorBox(GreenBG, RedFG);
	e.setConsoleSize();
	//Заполняем изначальные значения контейнеров
	auto fillCon = [&m](std::vector<int>& A, std::vector<int>& B) {
		std::string t; //Строка ввода данных
		m.clsBox()// Очищаем поле вывода
			.printBox("\nВведите размер контейнера A :");
		std::getline(std::cin, t);
		//Переводим строку в число
		int rA = std::stoi(t); //Размерность контейнера А 
		m.printBox("\nВведите размер контейнера B :");
		std::getline(std::cin, t);
		int rB = std::stoi(t); //Размерность контейнера А 
		A = randVec(-10, 10, rA);//Заполняем первый массив
		B = randVec(-10, 10, rB);//Заполняем второй массив
		//Уменшаем размеры контейнеров для экономии памяти
		A.capacity();
		B.capacity();
		m.printBox("\nМассив А :\n" + toStr(A));
		m.printBox("\nМассив B :\n" + toStr(B));
		};
	//Задание 14.1
	m.addItem("Задание 14.1", 
		[&m, &fillCon] {
			std::vector<int> A, B; //Контейнеры для заполнения
			fillCon(A, B);
			std::set<int> C; //Итоговый контейнер не дает добавлять повторяющиеся значения
			// Отбор элементов из A, которых нет в B
			std::copy_if(A.begin(), A.end(), std::inserter(C, C.end()),
				[&B](int x) {
					return std::find(B.begin(), B.end(), x) == B.end(); 
				});
			m.printBox("\nМассив C :\n" + toStr(C));
		},
		[&m] {
			m.clsBox()
				.printBox("Задание 1: Даны два контейнера: А[M] и B[N] (M и N вводятся с клавиатуры). Контейнеры заполняются случайными числами в диапазоне [-10;10]. Необходимо создать третий минимально возможного размера, в котором нужно собрать элементы контейнера A, которые не включаются в контейнер B, без повторений.	\nРешить задачу необходимо используя инструменты библиотеки <algorithm>, ямбда выражения, контейнеры(коллекции) из библиотеки std.");
		}
	);
	//Задание 14.2
	m.addItem("Задание 14.2",
		[&m, &fillCon] {
			std::vector<int> A, B; //Контейнеры для заполнения
			fillCon(A, B);
			std::set<int> C; //Итоговый контейнер не дает добавлять повторяющиеся значения
			for (int i : A) //Добавляем элементы из первого массива
				C.insert(i);
			for (int i : B)//Добавляем элементы из второго массива
				C.insert(i);
			m.printBox("\nМассив C :\n" + toStr(C));
		},
		[&m] {
			m.clsBox()
				.printBox("Задание 2: Даны два контейнера: А[M] и B[N] (M и N вводятся с клавиатуры). Контейнеры заполняются случайными числами в диапазоне [-10;10]. Необходимо создать третий минимально возможного размера, в котором нужно собрать элементы контейнеров A и B, которые не являются общими для них, без повторений.\nРешить задачу необходимо используя инструменты библиотеки <algorithm>, ямбда выражения, контейнеры(коллекции) из библиотеки std.");
		}
	);
	//Задание 14.3
	m.addItem("Задание 14.3",
		[&m, &fillCon] {
			std::vector<int> A, B, C; //Контейнеры для заполнения
			fillCon(A, B);
			C.insert(C.end(), A.begin(), A.end()); //Добавляем к С все элементы А
			C.insert(C.end(), B.begin(), B.end());//Добавляем к С все элементы В
			std::sort(C.begin(), C.end()); //Сортируем в порядке возрастания
			m.printBox("\nМассив C :\n" + toStr(C));
		},
		[&m] {
			m.clsBox()
				.printBox("Задание 3: Даны два контейнера: А[M] и B[N] (M и N вводятся с клавиатуры). Контейнеры заполняются случайными числами в диапазоне [-10;10]. Необходимо создать третий минимально возможного размера, в котором нужно собрать элементы обоих контейнеров.\nРешить задачу необходимо используя инструменты библиотеки <algorithm>, ямбда выражения, контейнеры(коллекции) из библиотеки std.");
		}
	);
	//Задание 14.4
	m.addItem("Задание 14.4",
		[&m, &fillCon] {
			std::vector<int> A, B, C; //Контейнеры для заполнения
			fillCon(A, B);
			C.insert(C.end(), A.begin(), A.end()); //Добавляем к С все элементы А
			C.insert(C.end(), B.begin(), B.end());//Добавляем к С все элементы В
			std::sort(C.begin(), C.end()); //Сортируем в порядке возрастания
			auto last = std::unique(C.begin(), C.end());//Перемещаем дубликаты в конец, получаем итератор конца
			C.erase(last, C.end());//Обрезаем конеец
			m.printBox("\nМассив C :\n" + toStr(C));
		},
		[&m] {
			m.clsBox()
				.printBox("Задание 4: Даны два контейнера: А[M] и B[N] (M и N вводятся с клавиатуры). Контейнеры заполняются случайными числами в диапазоне [-10;10]. Необходимо создать третий минимально возможного размера, в котором нужно собрать общие элементы двух контейнеров без повторений.\nРешить задачу необходимо используя инструменты библиотеки <algorithm>, ямбда выражения, контейнеры(коллекции) из библиотеки std.");
		}
	);
	//Задание 14.5
	m.addItem("Задание 14.5",
		[&m] {

		},
		[&m] {
			m.clsBox()
				.printBox("Задание 5: Дан контейнер: А[M] (M вводится с клавиатуры). Необходимо удалить из контейнера четные или нечетные значения. Пользователь вводит данные в конейнер, а также с помощью меню решает, что нужно удалить.\nРешить задачу необходимо используя инструменты библиотеки <algorithm>, ямбда выражения, контейнеры(коллекции) из библиотеки std.");
		}
	);
	
	m.addItem("Выход", [] {exit(0); }, [&m] {m.clsBox().printBox("Выход"); });
	m.setBox(m.getWidth() + 3, 1, e.getX(), e.getY());
	std::cout << m.run();
}

template <typename T>
std::string Task::toStr(const std::vector<T>& v) {
	std::string r;
	r += "[";
	for (int i = 0; i < v.size(); i++)
		r += std::to_string(v[i]) + ((i < v.size() - 1) ? ", " : "");
	r += "]";
	return r;
}

template <typename T>
std::string Task::toStr(const std::set<T>& v) {
	std::string r = "[";
	for (auto i = v.begin(); i != v.end() ; i++)
		r += std::to_string(*i) + " " +((std::next(i) != v.end()) ? ", " : "");
	r += "]";
	return r;
}

std::vector<int> Task::randVec( int min, int max, int size) {
	std::vector<int> v;
	for (size_t i = 0; i < size; i++)//Заполняем первый массив
		v.push_back(rand() % (max - min + 1) + min);
	v.capacity(); //Очищаем лишнюю память из вектора
	return v;
}